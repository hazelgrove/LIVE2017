% !TEX root = hazelnut-dynamics-LIVE2017.tex
% \newcommand{\introSec}{Introduction}
% \section{\protect\introSec}
% \label{sec:intro}

Broadly speaking, live programming environments are those that granularly interleave editing and evaluation \cite{DBLP:conf/icse/Tanimoto13,DBLP:journals/vlc/Tanimoto90,McDirmid:2007:LUL:1297027.1297073,burckhardt2013s}. 
In the words of \citet{burckhardt2013s}, live programming environments 
``promise to narrow the temporal and perceptive gap 
between program development and code execution''. Examples of live programming environments include {lab notebook environments},
e.g. the popular IPython/Jupyter~\cite{PER-GRA:2007}, which allow the
programmer to interactively edit and evaluate program fragments organized into a
sequence of cells (an extension of the read-eval-print loop (REPL)); spreadsheets; {live graphics programming environments} like SuperGlue \cite{McDirmid:2007:LUL:1297027.1297073}, Sketch-n-Sketch \cite{DBLP:conf/pldi/ChughHSA16} and the tools demonstrated by Bret Victor in his lectures \cite{victor2012inventing}; the TouchDevelop live UI framework \cite{Burckhardt:2013:ACF:2491956.2462170}; and live visual and auditory dataflow languages \cite{DBLP:conf/vl/BurnettAW98}, to name just a few prominent examples.


The problem that motivates this paper is that 
contemporary live programming environments are equipped only to provide feedback, via various editor services, once the program being edited is syntactically well-formed and, when relevant, well-typed. This leaves a temporal and perceptive gap, because programmers sometimes leave a program malformed or ill-typed for extended periods of time (e.g. as they work on another part of the program.)

In view of this problem, we recently developed a \emph{structure editor calculus} called Hazelnut where every edit state consists of a well-formed and statically meaningful, i.e. well-typed, expression with holes \cite{popl-paper}. This calculus addressed fundamental problems relevant to editor services that operate statically, but there was no solution in that paper to the problems faced by editor services characteristic of live programming environments, which also require knowledge of the dynamic meaning of an incomplete program. In particular, a \emph{stepper} (also known as a \emph{step-wise debugger}) quite obviously requires that the expression being stepped be assigned dynamic meaning according to, for example, a small-step operational semantics \cite{DBLP:journals/jlp/Plotkin04a,pfpl}, but no such semantics was defined for the incomplete expressions that arise when using Hazelnut. Defining such a semantics was left as future work in that paper, and in a subsequent ``vision paper'' \cite{snapl17-paper}. The purpose of this paper is to sketch out our progress towards a solution to this problem. Let us immediately emphasize that we have not yet fully solved this problem -- this paper presents work in progress.

% \section{Example}

%% \begin{figure}[ht]
%% \center
%% \small
%% \ensuremath{
%% \begin{array}{rclcrcl}
%% \multicolumn{3}{l}{\textbf{\ScenerioOne: Test, Suspend, Edit}}
%% &
%% &
%% \multicolumn{3}{l}{\textbf{\ScenerioTwo: Edit, Test}}
%% \\
%% \hline
%% \texttt{fun}~f(x,y) &=& 3 + x * y {\div} \hehole^\metavar_\textrm{id}
%% &
%% &
%% \texttt{fun}~f(x,y) &=& 3 + x * y {\div} \hehole^\metavar_\textrm{id}
%% \\
%% \multicolumn{3}{l}{
%% \colorbox{dVeryFaint}{  
%% \textrm{where}~$\textrm{id} = [x/x, y/y]$
%% }}
%% &
%% &
%% \multicolumn{3}{l}{
%% \colorbox{dVeryFaint}{  
%% \textrm{where}~$\textrm{id} = [x/x, y/y]$
%% }}
%% \\
%% &&&&
%% \desc{Insert~$(x+1)$}& \leadsto & 3 + x * y {\div} \hehole{x+1}^\metavar_\textrm{id}
%% \\
%% &&&&
%% \desc{Finalize}& \leadsto & 3 + x * y {\div} (x+1)
%% \\[2mm]
%% % - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%% \hline
%% f(2,3) &\longmapsto & 3 + 2 * 3 {\div} \hehole^\metavar_\sigma
%% &&
%% f(2,3) &\longmapsto & 3 + 2 * 3 {\div} (2+1)
%% \\
%% &\longmapsto& 3 + 6 {\div} \hehole^\metavar_\sigma
%% &
%% %% \multicolumn{2}{l}{
%% %% \colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]~\circ~{\textsf{det}}}$}
%% %% }
%% \multicolumn{1}{l}{
%% \colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}$}
%% }
%% && \longmapsto& 3 + 6 {\div} (2 + 1)
%% \\
%% &\longmapsto& 3 + \indetaction{\lfloor} 6 {\div} \hehole^\metavar_{\sigma} \indetaction{\rfloor}
%% &&& \longmapsto& 3 + 2
%% \\
%% &\longmapsto& \indetaction{\lfloor} 3 + \lfloor 6 {\div} \hehole^\metavar_\sigma \rfloor \indetaction{\rfloor}
%% &&& \longmapsto& 5
%% \\
%% \multicolumn{3}{r}{
%%         \colorbox{dVeryFaint}{
%%           \textrm{where}~$\sigma = [2/x,3/y]$
%%         }
%% }
%% \end{array}
%% }
%% \caption{Two testing scenerios, related by the edit~$[\!| (x+1) / u |\!]$ (CMTT hole instantiation).}
%% \label{fig:dynamics}
%% \end{figure}

\newcommand{\linenumber}[1]{{\color{gray} \texttt{#1}}}
\begin{figure}[ht]
\center
\small
\ensuremath{
\arraycolsep=4pt
\begin{array}{rrclcrcl}
\multicolumn{4}{l}{\textbf{Scenario 1: Testing}}
&
&
\multicolumn{3}{l}{\textbf{Scenario 2: Edit and Resume}}
\\
\hline
&
\multicolumn{3}{l}{\texttt{fun}~f(x,y) = 3 + x * y {\div} \hehole{\metavar}_{[x/x,y/y]} + 2 * y}
&
\multicolumn{1}{l}{
\colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}$}
}
&
\multicolumn{3}{l}{\texttt{fun}~f(x,y) = 3 + x * y {\div} (x+1) + 2 * y}
% \\
% \multicolumn{3}{l}{
% \colorbox{dVeryFaint}{  
% \textrm{where}~$\textrm{id} = [x/x, y/y]$
% }}
% &
% &
%\multicolumn{3}{l}{
%\colorbox{dVeryFaint}{  
%\textrm{where}~$\textrm{id} = [x/x, y/y]$
%}}
\\
% - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\hline
\linenumber{1} & 
f(2,3) &\longmapsto & 3 + 2 * 3 {\div} \hehole{\metavar}_{[2/x, 3/y]}  + 2 * 2
&
\multicolumn{1}{l}{
\colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}$}
}
&
f(2,3) &{\longmapsto} & {3 + 2 * 3 {\div} (2+1) + 2 * 2}
\\
\linenumber{2} & 
&\longmapsto& 3 + 6 {\div} \hehole{\metavar}_{[2/x, 3/y]} + 2 * 2
&
\multicolumn{1}{l}{
\colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}$}
}
&& {\longmapsto} & {3 + 6 {\div} (2 + 1) + 2 * 2}
\\
\linenumber{3} &
&\longmapsto & 3 + 6 {\div} \heholechk{\metavar}_{[2/x, 3/y]} + 2 * 2
% \multicolumn{3}{l}{
%         \colorbox{dVeryFaint}{
%           \textrm{where}~$\sigma = [2/x,3/y]$
%         }
% }
%&&
% &\longmapsto& 3 + \indetaction{\lfloor} 6 {\div} \hehole^\metavar_{\sigma} \indetaction{\rfloor}
&\multicolumn{1}{l}{
\colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}$}
}
&& \longmapsto& {3 + 6 {\div} 3 + 2 * 2}
\\
\linenumber{4} &
&&
&&& \longmapsto& 3 + 2 + 2 * 2
\\
\linenumber{5} &
&&
&&& \longmapsto & 5 + 2 * 2
\\
\linenumber{6} &
& \longmapsto &3 + 6 {\div} \heholechk{\metavar}_{[2/x, 3/y]} + 4 
% &\longmapsto& \indetaction{\lfloor} 3 + \lfloor 6 {\div} \hehole^\metavar_\sigma \rfloor \indetaction{\rfloor}
&
\multicolumn{1}{l}{
\colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}\mapsto^{*}$}
}
&& \longmapsto & 5 + 4
\\
\linenumber{7} &
&& 
&&& \longmapsto & 9
% \multicolumn{1}{l}{
% \colorbox{dVeryFaint}{$\xrightarrow{[\!| (x+1) / u |\!]}$}
% }
\end{array}
}
\caption{An example demonstrating (1) evaluation of an incomplete program; (2) support for ``edit-and-resume'' when transitioning between edit states related by an edit that can be understood as hole instantiation.}
\label{fig:dynamics}
\end{figure}

\noindent\textbf{Scenario 1: Testing.} Consider the simple incomplete function $f$ defined in Figure \ref{fig:dynamics} (top left).  
%
A hole appears in the denominator of the division. In the previous section,
holes were unadorned. In this section, it will be helpful to adorn each hole with a unique name, $u$. In addition, each hole is adorned with an \emph{environment} that defines a substitution for each variable in scope
where the hole appears. Initially, the environment is the appropriate identity substitution -- in this example, $[x/x, y/y]$. 

A subsequent cell (bottom left) applies $f$ to $2$ and $3$ (perhaps because the programmer intends this to be a test of $f$). Function application operates in the usual way: 
we substitute $2$ for $x$ and $3$ for $y$ in the body of $f$. Substitution proceeds also into the environment associated with each hole -- here, the environment for hole $u$ becomes $[2/x, 3/y][x/x, y/y] = [2/x, 3/y]$.

The next step of evaluation proceeds to reduce $2 * 3$ to $6$, again in the usual way.
%
The next step would divide $6$ by a number, except that the number is
absent; there is a hole in its place. No evaluation step can be taken. 
%
Normally, this would violate the classical notion of Progress -- 
evaluation can neither proceed, nor has it produced a value. We conjecture that this is
resolved by (1) positively characterizing \emph{indeterminate} 
evaluation states, those where a hole blocks progress at all locations
within the expression, and (2) defining
a notion of Indeterminate Progress that allows for evaluation to stop at an 
indeterminate evaluation state. This ``fix'' is in some ways analagous to the fix needed when introducing 
run-time errors into a language \cite{pfpl}.\footnote{%
This example is similar to the example shown in cell~\textbf{(c)} in
Figure~\ref{fig:hazel-mockup}, except that there, we also applied
the heuristic that we should not step
into the definition of {std} because it was defined in an imported library.}

\vspace{0.25ex}
\noindent\textbf{Scenario 2: Edit and Resume.}
Suppose the programmer decides that the denominator should
be $x+1$, and, through some sequence of edits (considered formally in the next section), arrives at 
the new definition of $f$ shown on the top right of Figure \ref{fig:dynamics}. This edit state is now complete -- no holes remain -- so the live programming environment 
could evaluate $f(2, 3)$ in the usual way by taking the steps shown on
the bottom right of Figure \ref{fig:dynamics} (including the first
grayed out step).

However, if the editor has already computed the indeterminate evaluation 
state from the version of $f$ with a hole, and it also knows that the 
two edit states differ only up to \emph{hole instantiation}, written 
$[\!| (x+1) / u
|\!]$, then it can take advantage of an important commutativity property that we aim 
to prove about our dynamics: that 
\emph{hole instantiation commutes with evaluation}. 

Hole instantiation, $[\!| \hexp / u |\!]\hexp'$ is similar to substitution, except that it acts on
 hole(s) named $u$ in $\hexp'$. At each such hole, the corresponding substitution is applied to $\hexp$. For example,
% $[\!| x + 1 / u |\!]\hehole^\metavar_{[2/x, 3/y]} = 2 + 1$. 

Assuming hole instantiation commutes with evaluation, then it suffices to start from any indeterminate evaluation 
state previously computed and perform hole instantiation on it. After doing so, evaluation can resume. The end result is guaranteed to coincide with that of evaluating the new version of $f$ from scratch. In Figure \ref{fig:dynamics}, this implies that we need not perform the two grayed out evaluation steps. This relates to PI Hammer's
ongoing research into combining general-purpose incremental
computation (IC) with static analysis~\cite{OVV2016}. 
%
Currently, IC research focuses on input
changes~\citep{TypedAdapton2016, Fisher2016, Hammer2015, Chen2014,
Hammer2014, Chen2011, Hammer2011, Hammer2009, Hammer2008}, whereas the
work proposed here considers incremental \emph{program changes}.

The notion of holes being associated with unique names and substitutions, and the notion of hole instantiation just described, is borrowed directly from work in \emph{contextual modal type theory (CMTT)} \cite{Nanevski2008}. Hole names correspond to \emph{metavariables} and holes themselves to \emph{closures}. CMTT is, in turn, the Curry-Howard interpretation of contextual modal logic. This gives us confidence that our approach is not \emph{ad hoc}, but rather rooted in the established logical tradition.

\subsection{Proposed Research}

\noindent\textbf{Core Semantics.} The preliminary work outlined above, with its roots in CMTT, suggests a theoretical foundation for moving forward. However, there remain two major missing pieces:

First, CMTT does not come equipped with a dynamic semantics that supports evaluation of terms with free metavariables, which is precisely what we require (see Scenario 1, above). As such, we need to formally develop the notion of an \emph{indeterminate evaluation state}, define a dynamics that can handle free metavariables, and formally state and prove our Indeterminate Progress and commutativity conjectures. We also need to carefully consider how non-termination (and, perhaps, other effects) affects the commutativity property.

Second, CMTT's closures nicely handle empty expression holes, but non-empty holes, type holes, and other problems that we plan to internalize with our statics need to be considered carefully. Non-empty holes can likely be understood as a simple variation on empty holes. In the previous section, we discussed the relationship between type holes and gradual typing. Work in gradual typing appears to provide one solution to the problem of evaluating terms with type holes (by inserting run-time casts \cite{Siek06a}.) This suggests that a comprehensive dynamics for incomplete programs, i.e. one that assigns dynamic meaning to every statically meaningful incomplete program, will require developing a \emph{gradual contextual modal type theory} (GCMTT).

\paragraph{Further Developments.} There are several more practical applications that we aim to explore after developing the initial foundations just described.

It would be useful for the programmer to be able to select a hole that appears in an indeterminate state and 1) be taken to its original location; 2) be able to inspect the \emph{value} of a subexpression under the cursor in the environment of the selected hole (rather than just its type.)

We need to develop a semantics that characterizes when two edit states are related by hole instantiation. There are two ways to approach this: as a function of the ``diff'' between the two edit states; and 2) as a function of an edit action that was actually performed (see the next section.)

IPython/Jupyter \cite{Perez:2007:ISI:1251563.1251831} supports a feature whereby numeric variable(s) in cells can be marked as being ``interactive'', which causes the user interface to display a slider. As the slider value changes, the new value of the cell is recomputed. It would be useful to be able to use the mechanisms just described to incrementalize parts of this recomputation automatically.


